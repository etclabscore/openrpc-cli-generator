// Code generated by go-openrpc. DO NOT EDIT.

// This example program starts a basic HTTP server that would act as a proxy
// to the upstream server described by an Open-RPC configuration.

package main

import (
	"log"
	"net/http"
	rpct "github.com/gregdhill/go-openrpc/rpc"
	"encoding/json"
	"reflect"
	"bytes"
	"io/ioutil"
)


// https://github.com/a8m/reflect-examples#wrap-a-reflectvalue-with-pointer-t--t
func ptr(v reflect.Value) reflect.Value {
	pt := reflect.PtrTo(v.Type())
	pv := reflect.New(pt.Elem())
	pv.Elem().Set(v)
	return pv
}

func ResultToStruct(msg json.RawMessage, res interface{}) error {
	var err error
	val := reflect.ValueOf(res)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	// Get first (and only field)
	field := val.Field(0)
	if field.CanSet() {
		pf := ptr(field)
		err = json.Unmarshal(msg, pf.Interface())
		if err != nil {
			return err
		}
		field.Set(pf.Elem())
	}
	return nil
}

var gethClientRPC string

type exampleRPCService struct{}

{{- range .Methods }}
{{- $name := .Name | camelCase }}
{{- $params := (maybeMethodParams .) }}
{{- $result := (maybeMethodResult .) }}
{{- $method := printf "%s" $name }}
{{- $original_method := printf "%s" $name }}
{{- if $params }}
{{- $method = printf "%s(params *rpct.%s)" $method $params }}
{{- else }}
{{- $method = printf "%s()" $method }}
{{- end }}
{{- if $result }}
{{- $method = printf "%s (result *rpct.%s, err error)" $method $result }}
{{- else }}
{{- $method = printf "%s error" $method $result }}
{{- end }}
{{ printf "func (s *exampleRPCService) %s {" $method }}
{{- if $params }}
{{ printf "defer log.Println(\"%s\", \"params=\", params)" .Name }}
{{- end }}
{{ printf "defer log.Println(`%s`)" .Name }}

req := rpct.RPCRequest{
		JSONRPC: "2.0",
		Method:  "{{ .Name }}",
		Params:  []byte("[]"),
		ID:      1,
	}

{{- if $params }}
	if params != nil {
		set := []interface{}{}
		val := reflect.ValueOf(params).Elem()

		for i := 0; i < val.NumField(); i++ {
			valField := val.Field(i)
			set = append(set, valField.Interface())
		}

		b, err := json.Marshal(set)
		if err != nil {
			return nil, err
		}

		req.Params = b
	}
{{- end }}

	reqB, err := json.Marshal(&req)
	if err != nil {
		return nil, err
	}
  log.Println("posting", string(reqB))
	buf := bytes.NewBuffer(reqB)
	res, err := http.Post(gethClientRPC, "application/json", buf)
	if err != nil {
    log.Println("POST error:", err)
		return nil, err
	}

{{- if $result }}

	gotB, err := ioutil.ReadAll(res.Body)
	if err != nil {
    log.Println("read body error:", err)
		return nil, err
	}

  // TODO: handle server error response

  gotRes := &struct{
    JSONRPC string      `json:"jsonrpc"`
    Result  json.RawMessage `json:"result"`
    ID      interface{} `json:"id"`
  }{}

	err = json.Unmarshal(gotB, gotRes)
	if err != nil {
    log.Println("json unmarshal error:", err, "data", string(gotB))
		return nil, err
	}
  log.Println("received OK response:", string(gotB))

  wantRes := new(rpct.{{ $result }})
  err = ResultToStruct(gotRes.Result, wantRes)
  if err != nil {
    log.Println("result to struct error:", err, "result", gotRes.Result)
    return nil, err
  }

	return wantRes, nil

{{- else }}

  return

{{- end }}

{{ printf "%s" "}" }}
{{- end }}

func main() {
     gethClientRPC = "http://localhost:8545"
     service := new(exampleRPCService)
     server := rpct.NewServer(service)

     s := http.Server{
       Addr: ":3000",
       Handler: server,
     }
     log.Println("Expecting upstream eth RPC endpoint at", gethClientRPC)
     log.Println("Serving on http://localhost:3000 ...")
     log.Fatal(s.ListenAndServe())
}