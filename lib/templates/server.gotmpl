// Code generated by go-openrpc. DO NOT EDIT.

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"reflect"
)

const JSONRPC = "2.0"

type Code uint32

const (
	ErrUnknown Code = iota
	ErrCouldNotParse
	ErrInvalidRequest
	ErrNotFound
	ErrInvalidParams
	ErrInternal
	ErrServer
)

func (c Code) Error() string {
	return fmt.Sprintf("Error %d: %s", c, c.String())
}

func (c Code) String() string {
	switch c {
	case ErrCouldNotParse:
		return "could not parse input"
	case ErrInvalidRequest:
		return "invalid request"
	case ErrNotFound:
		return "not found"
	case ErrInvalidParams:
		return "invalid parameters"
	case ErrInternal:
		return "internal error"
	case ErrServer:
		return "server error"
	default:
		return "unknown error"
	}
}

func (c Code) RPCError() *RPCError {
	switch c {
	case ErrCouldNotParse:
		return NewRPCError(-32700, c.String())
	case ErrInvalidRequest:
		return NewRPCError(-32600, c.String())
	case ErrNotFound:
		return NewRPCError(-32601, c.String())
	case ErrInvalidParams:
		return NewRPCError(-32602, c.String())
	case ErrInternal:
		return NewRPCError(-32603, c.String())
	case ErrServer:
		return NewRPCError(-32000, c.String())
	default:
		return NewRPCError(-32099, c.String())
	}
}

func (c Code) RPCErrorWithMessage(msg string) *RPCError {
	resp := c.RPCError()
	resp.Message = msg
	return resp
}

// https://www.jsonrpc.org/specification#request_object
type RPCRequest struct {
	JSONRPC string          `json:"jsonrpc"`
	Method  string          `json:"method"`
	Params  json.RawMessage `json:"params"`
	ID      interface{}    	`json:"id"`
}

// https://www.jsonrpc.org/specification#response_object
type RPCResultResponse struct {
	JSONRPC string      `json:"jsonrpc"`
	Result  interface{} `json:"result"`
	ID      interface{} `json:"id"`
}

// https://www.jsonrpc.org/specification#response_object
type RPCErrorResponse struct {
	JSONRPC string    	`json:"jsonrpc"`
	Error   *RPCError 	`json:"error"`
	ID      interface{} `json:"id"`
}

// https://www.jsonrpc.org/specification#error_object
type RPCError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

func NewRPCError(code int, msg string) *RPCError {
	return &RPCError{Code: code, Message: msg}
}

type Server struct {
	service GoOpenRPCService
}

func NewServer(rpc GoOpenRPCService) *Server {
	return &Server{rpc}
}

func (srv *Server) HandleHTTP(rpcPath string) {
	http.Handle(rpcPath, srv)
}

// https://github.com/a8m/reflect-examples#wrap-a-reflectvalue-with-pointer-t--t
func ptr(v reflect.Value) reflect.Value {
	pt := reflect.PtrTo(v.Type())
	pv := reflect.New(pt.Elem())
	pv.Elem().Set(v)
	return pv
}

func ParamsToStruct(msg json.RawMessage, req interface{}) error {
	// by-name
	err := json.Unmarshal(msg, req)
	if err == nil {
		return nil
	}

	// by-position
	params := make([]json.RawMessage, 0)
	err = json.Unmarshal(msg, &params)
	if err != nil {
		return err
	}
	val := reflect.ValueOf(req)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}

	for i, p := range params {
		if i >= val.NumField() {
			break
		}
		field := val.Field(i)
		if field.CanSet() {
			pf := ptr(field)
			err = json.Unmarshal(p, pf.Interface())
			if err != nil {
				return err
			}
			field.Set(pf.Elem())
		}
	}
	return nil
}

func StructToResult(in interface{}) interface{} {
	val := reflect.ValueOf(in)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	if val.Kind() != reflect.Struct {
		return in
	}
	if val.NumField() == 1 {
		return val.Field(0).Interface()
	} else if val.NumField() > 1 {
		result := make([]interface{}, 0)
		for i := 0; i < val.NumField(); i++ {
			field := val.Field(i)
			if val.Kind() == reflect.Ptr {
				field = field.Elem()
			}

			if field.Kind() == reflect.Slice {
				for i := 0; i < field.Len(); i++ {
					result = append(result, field.Index(i).Interface())
				}
			} else if field.CanInterface() {
				result = append(result, field.Interface())
			}
		}
		return result
	} else {
		return nil
	}
}

func (srv *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodOptions {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET")
		w.Header().Set("Access-Control-Allow-Headers", "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range")
		w.Header().Set("Accept-Range", "bytes")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte{})
		return
	} else if r.Method != http.MethodPost {
		WriteError(w, "", ErrInternal.RPCError())
		return
	}

	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		WriteError(w, nil, ErrInvalidRequest.RPCError())
		return
	}
	r.Body.Close()

	in := new(RPCRequest)
	err = json.Unmarshal(data, in)
	if err != nil {
		WriteError(w, nil, ErrCouldNotParse.RPCError())
		return
	}

	if in.JSONRPC != JSONRPC || in.Method == "" || in.ID == nil {
		WriteError(w, nil, ErrInvalidParams.RPCError())
		return
	}

	var out interface{}

	switch in.Method {
	{{- range .Methods }}
	case "{{ .Name }}":
	{{- $name := .Name | camelCase }}
	{{- $params := maybeMethodParams . }}
	{{- $result := maybeMethodResult . }}

	{{- if $params }}
		req := new({{ $params }})
		err = ParamsToStruct(in.Params, req)
		if err == nil {
			{{- if $result }}
			out, err = srv.service.{{ $name }}(req)
			{{- else }}
			err = srv.service.{{ $name }}(req)
			{{- end }}
		}
	{{- else }}
		{{- if $result }}
		out, err = srv.service.{{ $name }}()
		{{- else }}
		err = srv.service.{{ $name }}()
		{{- end }}
	{{- end }}

	{{- end }}
	}

	if err != nil {
		WriteError(w, in.ID, ErrInternal.RPCErrorWithMessage(err.Error()))
		return
	}

	WriteData(w, in.ID, out)
}

func WriteError(w http.ResponseWriter, id interface{}, resp *RPCError) {
	data, err := json.Marshal(&RPCErrorResponse{
		JSONRPC: JSONRPC,
		Error:   resp,
		ID:      id,
	})
	if err != nil {
		panic(err)
	}
	w.Header().Set("Content-Type", "application/json")
	w.Write(data)
}

func WriteData(w http.ResponseWriter, id interface{}, result interface{}) {
	resp := &RPCResultResponse{
		JSONRPC: JSONRPC,
		ID:      id,
		Result:  StructToResult(result),
	}
	data, err := json.Marshal(resp)
	if err != nil {
		WriteError(w, id, ErrInternal.RPCError())
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(data)
}